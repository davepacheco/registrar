registrar:
- reads config file from --file?
  cfg.zookeeper (object: passed to internal createZkClient)
      non-empty array of objects "servers", each with "host" and "port"
  cfg.healthCheck
      "command": string
      "ignoreExitStatus": optional boolean
          if not true, then command failure is a check failure
	  if true, any command failure is ignored
      "interval": optional number
          default: 60000
	  will run the command this often
      "stdoutMatch": optional object, only effective with a pattern
      "stdoutMatch.pattern": optional string
          regexp
      "stdoutMatch.flags": optional string
          used for the regexp
      "stdoutMatch.invert": optional boolean
          IGNORED
      "period": optional number
          default: 300000
	  must fail "threshold" times in "period" time
	  XXX does this work at all?  We only call _period() once ever.
	  We also never set fails to [] any other time (e.g., when we suceeed)
      "threshold": optional number
          default: 5
	  only mark the service down if it fails this many times before
	  _period() runs...
      "timeout": optional number
          default: 1000
	  kill command with SIGTERM after this long
	  (doesn't necessarily imply failure)
      notes: uses fixed-size 1MB buffer

  transformation: 

        // backward compatible with top-level 'adminIp' in configs.
        cfg.registration.adminIp = cfg.registration.adminIp || cfg.adminIp;

  
  register opts
  - adminIp (optional string)
  - aliases (optional object) (really an array)
  - domain (string)
  - registration (object)
    type (string)
    ttl (optional number)
    ports (optional array of number)
    service (optional object)
    - type (string): must be "service"
      service (object)
      - srvce (string)
      - proto (string)
      - ttl (optional number: default 60)
      - port (number)

"nodes" argument is an array with entries:

   [ $hostname.$domain_as_path ] concat aliases

actual registration creates ephemeral nodes for each "nodes":

   {
       type: registration.type,
       address: adminIp if present, otherwise the first non-internal address
           found from os.networkInterfaces
       ttl: registration.ttl
       ports: registration.ports OR registration.service.service.port
       $type: {
           address: adminIp or first non-internal address found
	   ports: same as above
       }
   }


Over in binder:

lookup calls zk.resolveName(), which calls getNameRecord(), which just fetches
the data out and parses it as JSON.

If type != "service", we return that back.
If type == "service", that's load balanced.  We fetch child nodes from ZK, and
we fetch the data for each one. "svc" is an array of the objects found, and
record.children is set to that.

Back in server.js:
- ttl: ttl on inner record, if present; else ttl on root; else 30 seconds
- switch on type:
  - if "database": parse "primary" and report as an A record
  - if "db_host", "host", "load_balancer", "moray_host", "redis_host":
    - add A record for the address found in the inner record
  - if "service": look at children with records "load_balancer", "moray_host",
    "ops_host", "rr_host", or "redis_host", shuffle them.
    - ports are taken from child's inner record .ports, or else the port on the
      "service.service" record.
    - if SRV request, add SRV answers based on the subrecord's "name" and
      domain and all of the ports found.  Also adds A records.
    - otherwise: add A records for the address in the child record's inner
      record.

note: "database" records appear that they used to be written by manatee, but
haven't been since 2012.

Questions:
- is there a difference between load_balancer, moray_host, ops_host, rr_host, or
  redis_host?  What about db_host or host?
